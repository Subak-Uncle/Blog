# JPA Entity Unique key지정 방식 비교

JPA에서 제공하는 UNIQUE KEY 지정방식에는 두가지가 있다.

```
// 1번 방식
@Table(name="Member", uniqueConstraints = {
        @UniqueConstraint(
                name="NAME_AGE_UNIQUE",
                columnNames={"NAME","AGE"}
        )})

 /// 2번 방식
 @Column(name="name",unique = true) 
```

유니크 키를 지정하는 방식에는 두가지 방법이 있다.

1. @Table 어노테이션에 속성값을 넣는 방법
2. @Column 어노테이션에 속성값을 넣는 방법

### 다중 칼럼에 유니크 키 걸기

2번 방식의 경우에는 필드위에 @Column 어노테이션을 통해 유니크 키를 추가하는 방식이므로 다중칼럼에 유니크 키를 걸 수가 없다.

이름과 폰번호가 모두 중복되는 것을 금지하는 제약조건을 추가하길 원한다고 가정해보자

```
/**** 1번 방식 *****/
@Entity()
@Table(name="Member", uniqueConstraints = {
        @UniqueConstraint(
                name="NAME_AGE_UNIQUE",
                columnNames={"NAME","AGE"}
        )})
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;    //이걸 왜 Wrapper자료형으로 잡을까?

    private String name;
    private String phone;
    }


/**** 2번 방식 *****/
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;    //이걸 왜 Wrapper자료형으로 잡을까?

    @Column(name="name",unique = true) //실행에는 영향을 주지 않는다. 단지 DDL생성에만 관여할 뿐이다.
    private String name;

    @Column(name="phone",unique = true)
    private String phone;
    }
```

ddl-auto를 create로 하고 각각의 방식에서 나타나는 ddl을 확인해보자.

```
//**  1번 방식 **//
Hibernate: 

    create table Member (
       id bigint generated by default as identity,
        name varchar(255),
        phone varchar(255),
        primary key (id)
    )

Hibernate: 

    alter table Member 
       add constraint NAME_AGE_UNIQUE unique (name, phone)

//**  2번 방식 **//

Hibernate: 

    create table Member (
       id bigint generated by default as identity,
        name varchar(10) not null,
        phone varchar(10) not null,
        primary key (id)
    )
Hibernate: 

    alter table Member 
       add constraint UK_ektea7vp6e3low620iewuxhlq unique (name)
Hibernate: 

    alter table Member 
       add constraint UK_redywmoh8x2ku6ab3ghhkk2nr unique (phone)
```

1번 방식의 경우 유니크 키를 (name,phone)으로 묶어 생성하는 반면
2번 방식의 경우 name,phone에 각각 unique키를 생성한다.
2번 방식대로 생성된 unique키는 name과 phone중에 하나라도 중복되는게 있다면 Exception을 발생시킨다.

이렇게 다중칼럼에 유니크 키를 생성하고싶을때는 선택지 없이 1번방식을 이용해야한다.

### 가독성 적인 측면

앞에서 봤던 DDL코드를 다시 확인해보자

```
//**  1번 방식 **//

Hibernate: 

    alter table Member 
       add constraint NAME_AGE_UNIQUE unique (name, phone)

//**  2번 방식 **//

Hibernate: 

    alter table Member 
       add constraint UK_ektea7vp6e3low620iewuxhlq unique (name)
Hibernate: 

    alter table Member 
       add constraint UK_redywmoh8x2ku6ab3ghhkk2nr unique (phone)
```

1번 방식에서는 설정한 NAME_AGE_UNIQUE 라는 이름으로 유니크 키가 잘 생성된 반면
2번 방식에서는 이해할 수 없는 문자열로 유니크 키가 생성되었다.
2번 방식에서는 유니크키의 이름을 따로 지정해줄 수가 없어서 한눈에 어떤 역할을 하는 키인지를 확인하기 힘들다.

### 결론

따라서 굳이 다중칼럼에 유니크 제약조건을 거는 경우가 아니더라도 1번 방식을 통해 유니크 제약조건을 거는 것이 여러 방면에서 더 유리함을 알 수 있다.